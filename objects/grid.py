import logging
import math_functions as mf
from objects.cell import Cell
from objects.datapoint import Datapoint

# Logger for everything (saves his log in logs/logfile.txt
logger = logging.getLogger('Grid')


class Grid:
    def __init__(self,
                 rows,
                 dimension,
                 columns=None,
                 cells=None,
                 ):
        """
        This class represents the grid used for my gridbased approach. It contains information about cells and data.
        :param rows: the number of rows
        :param dimension number of dimensions in the original data
        :param columns: the number of columns
        :param cells: initialise the list of cells
        """

        if rows:
            self.rows = rows
            self.columns = rows

        if columns is not None:
            self.columns = columns

        if cells:
            self.list_of_cells = cells

        self.cellwidth = 1 / (rows-2)

        self.neutral_variance = mf.calc_neutral_variance(self,dimension)

    @classmethod
    def autogenerated(cls,
                      rows,
                      dimension,
                      columns = None,
                      start_x=None,
                      start_y=None):
        """
        This method generates a grid. For this the method generates rows multiplied by columns empty cells
        :param rows: the number of rows
        :param dimension number of dimensions in the original data set
        :param columns: the number of columns
        number of cells
        :param start_x: the start value for the x coordinate. The default value is 0-cellwidth.
        :param start_y: the start value for the y coordinate. The default value is 0-cellwidth.
        :return: returns a grid object with generated cells
        """
        if columns:
            grid = Grid(rows,dimension, columns)
        else:
            grid = Grid(rows,dimension)


        # cellwidth
        cellwidth_x = 1 / (grid.rows-2)
        cellwidth_y = 1 / (grid.columns-2)

        # initial start_x and start_y
        start_x = 0 - cellwidth_x
        start_y = 0 - cellwidth_y

        list_of_cells = []
        # the cell id, starting by 0
        tmp_id = 0

        # add cells to grid
        for tmp_y in range(0, grid.columns):
            for tmp_x in range(0, grid.rows):
                list_of_cells.append(Cell(tmp_id, grid, posx=start_x + tmp_x * cellwidth_x,
                                          posy=start_y + (grid.columns - 1) * cellwidth_y - tmp_y * cellwidth_y, height=0))
                tmp_id += 1

        grid.list_of_cells = list_of_cells
        grid.set_direct_neighbours()

        # return the grid with generated cells
        return grid

    def init_points_to_right_cell(self, points):
        """
        This method gets a list of points. For every point it searched the correct cell by his x and y coordinate and
        add the point to this cell
        :param points:  list of points

        Raises:
            Raise a ValueError if the cell could not be found. This means the input was incorrect.
        """

        # if points is a Dataframe instead of a list
        if not isinstance(points, list):
            points_val = points.values
        else:
            points_val = points

        # for every point
        for index in range(0, len(points_val)):
            point = Datapoint.from_csv(points_val[index:index + 1])
            x = point.x_axis
            y = point.y_axis
            found = False
            for cell in self.list_of_cells:
                if cell.posx <= x <= cell.posx + self.cellwidth and cell.posy <= y <= cell.posy + self.cellwidth:
                    cell.add_point(point)
                    point.set_org(cell)
                    found = True
            if not found:
                logger.critical("ERROR by Point did not find cell for '%f', '%f'", point.x_axis, point.y_axis)
                #raise ValueError
                #pass

    def get_all_points(self):
        """
        This method returns every Point in the grid
        :return: a list_of_points with every point of every cell
        """
        list_of_points = []
        for cell in self.list_of_cells:
            list_of_points = list_of_points + cell.list_of_points
        return list_of_points

    def set_direct_neighbours(self):
        """
        This method iterates over the cells of the grid and sets the direct 4 neighbours for every cell
        """

        for cell in self.list_of_cells:
            if (cell.id + 1) % self.rows != 0:
                cell.direct_neighbours.append(self.get_cell(cell_id=cell.id + 1))
                self.get_cell(cell_id=cell.id + 1).direct_neighbours.append(cell)
            if cell.id + self.columns < self.columns * self.rows:
                cell.direct_neighbours.append(self.get_cell(cell_id=cell.id + self.columns))
                self.get_cell(cell_id=cell.id + self.columns).direct_neighbours.append(cell)

            cell.direct_neighbours = list(set(cell.direct_neighbours))
            logger.debug("List of direct neighbours for '%i' are '%s'", cell.id, cell.print_direct_neighbour())

    def get_cell(self, column=None, row=None, cell_id=None, point=None):
        """
        Returns a cell. Their are two different methods to search for a cell.
        First you can search with the coordinates of the cell. Second you can search by the id. You only need one of
        both. The id method is to prefer.

        :param column: the y coordinate of the searched cell
        :param row: the x coordinate of the searches cell
        :param cell_id: the id of the searched cell
        :param point the coordinate given as point
        :return: the searched cell

        Raises:
            Raise a ValueError if the cell could not be found. This means the input was incorrect.
        """
        if column and row:
            cell_id = row * self.rows + column
            for neuron in self.list_of_cells:
                if neuron.id == cell_id:
                    return neuron
            raise ValueError
            pass
        elif cell_id or cell_id == 0:
            for neuron in self.list_of_cells:
                if neuron.id == cell_id:
                    return neuron
            raise ValueError
            pass
        else:
            x = point.x_axis
            y = point.y_axis
            for cell in self.list_of_cells:
                if cell.posx <= x <= cell.posx + self.cellwidth and cell.posy <= y <= cell.posy + self.cellwidth:
                    return cell
            raise ValueError
            pass

    def calc_neighbourhood(self, max_distance, cell, visited_cells=None, costs=0, only_cells=False):
        """
        This method calculates a list with all cells of the neighbourhood for one specific cell

        :param max_distance: the maximals distance to go. Every cell in a smaller distance is reachable and part of the
        neighbourhood
        :param cell: the specific cell
        :param visited_cells: a list with all visited cells and their distance
        :param costs: the cost we already went.
        :param only_cells: if False the method returns a List with cells and distances,
        if true it returns only the cells
        :return: the neighbourhood as list
        """
        if visited_cells is None:
            visited_cells = []
        if not visited_cells:
            if only_cells:
                visited_cells = [cell]
            else:
                visited_cells = [[cell, 0]]

        for neighbour in cell.direct_neighbours:
            distance = costs + mf.calc_distance_2D(grid=self, cell=cell, neighbour=neighbour)
            if max_distance - distance >= 0:
                is_element = False
                for v in visited_cells:
                    if v[0] == neighbour:
                        is_element = True
                        if v[1] > distance:
                            v[1] = distance
                            is_element = False
                if not is_element:
                    if only_cells:
                        visited_cells.append(neighbour)
                    else:
                        visited_cells.append([neighbour, distance])
                    visited_cells = self.calc_neighbourhood(max_distance=max_distance, cell=neighbour,
                                                            visited_cells=visited_cells,
                                                            costs=distance)
        return visited_cells

    def sort_and_cut(self, percent=None, number_of_cells=5, searchparameter=lambda cell: cell.localerror):
        """
        This method gets a parameter to sort and after sorting it returns a list of cells with the percent
        highest values of the parameter or number_of_cells cells.
        :param percent: the percent of highest values to cut, as a int between 1 and 100. The default method to cut.
        :param number_of_cells: another method to cut the list after n elements. Only necessary if percent is 0
        :param searchparameter: the searchparameter als a lambda function. The default parameter is localerror. Another
        possibility is the Intracellvariance (ICV).
        :return: A list of cells. Sorted by the searchparameter, cut by percent.
        """
        sorted_list = sorted(self.list_of_cells, key=searchparameter)
        sorted_list = list(reversed(sorted_list))
        if percent:
            length = int(len(sorted_list) * percent / 100)
            return sorted_list[:length]
        else:
            return sorted_list[:number_of_cells]

    def set_mountains(self, new_heights):
        """
        This method gets a map of cells by id and new heights. It sets the new heights
        :param new_heights: a Map with cell by id and their new heights
        """
        for key, value in new_heights.items():
            self.get_cell(cell_id=key).height = value
